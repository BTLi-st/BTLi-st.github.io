[{"title":"markdown教程","url":"/2022/10/12/markdown%E6%95%99%E7%A8%8B/","content":"\nMarkDown入门指南\n\n1.关于MarkDownMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n优点\n轻量，码量极低\n简单，易于上手\n扩展，兼容Html和LaTeX\n\n缺点\n功能少，自定义程度低  \n\n例如原生不支持播放视频\n\n\n标准不统一，不同解释器兼容性不同 \n\n不是所有都支持完整Html和LaTex\n\n\n\n2.简单上手注意：本段只涉及MarkDown自带语法，在所有编辑器上均可正常显示\nMarkDown 标题Markdown 标题有两种格式。\n(1). 使用 = 和 - 标记一级和二级标题          MARKDOWN 共 4 行                      展开    这是一级标题=================这是二级标题-----------------\n\n\n这是一级标题这是二级标题\n(2). 使用 # 号标记          MARKDOWN 共 6 行                      展开    # 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题\n\n\n一级标题二级标题三级标题四级标题五级标题六级标题\nMarkDown 段落格式Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。当然也可以在段落后面使用一个空行来表示重新开始一个段落。\nMarkDown 字体格式(1). MarkDown字体          MARKDOWN 共 6 行                      展开    *斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___\n\n\n斜体文本斜体文本粗体文本粗体文本粗斜体文本粗斜体文本  \n\n(2). 删除线          MARKDOWN 共 1 行                      展开    ~~删除线~~\n\n删除线\n\n(3). 分隔线          MARKDOWN 共 9 行                      展开    **** * ******- - -----------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(4). 脚注          MARKDOWN 共 2 行                      展开    文本[^要注明的文本][^要注明的文本]: 脚注\n\n\n文本 ^1\n\n\n\nMardown 列表(1). 无序列表          MARKDOWN 共 12 行                      展开    * 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项\n\n\n\n第一项\n第二项\n第三项\n\n\n\n\n第一项\n第二项\n第三项\n\n\n\n\n第一项\n第二项\n第三项\n\n\n(2). 有序列表          MARKDOWN 共 3 行                      展开    1. 第一项2. 第二项3. 第三项\n\n\n\n第一项\n第二项\n第三项\n\n\n(3). 列表嵌套列表嵌套只需在子列表中的选项前面添加两个或四个空格即可\n          MARKDOWN 共 6 行                      展开    1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素\n\n\n\n第一项：\n第一项嵌套的第一个元素\n第一项嵌套的第二个元素\n\n\n第二项：\n第二项嵌套的第一个元素\n第二项嵌套的第二个元素\n\n\n\n\nMarkdown 区块          MARKDOWN 共 3 行                      展开    &gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套\n\n\n最外层\n\n第一层嵌套\n\n第二层嵌套\n\n\n\n在区块中可使用列表，同理，在列表中可使用区块\nMarkdown 代码(1). 在段落中显示代码片段          MARKDOWN 共 1 行                      展开    `代码片段`\n\n\nprint()函数\n\n(2). 代码区块使用一个tab键或四个空格键\nprint('Hello World!')\n\n使用```包裹\n          MARKDOWN 共 2 行                      展开    ```语言名称（可选）内容\n          TEXT 共 3 行                      展开    ```pythonprint('Hello World!')\n\nMarkdown链接          MARKDOWN 共 3 行                      展开    [链接名称](链接地址)或&lt;链接地址&gt;\n\n\npython课程资源https://www.bilibili.com/\n\nMarkdown图片          TEXT 共 3 行                      展开    ![alt text(替代文字)](图片地址)或![alt text(替代文字)](图片地址 \"可选标题\")\n\n\n\n\n替代文字会在图片无法加载时出现\n图片可以带上链接\n          MARKDOWN 共 1 行                      展开    ![alt text(替代文字)](图片地址)](链接地址)\n\n\n\n\nMarkdown列表          MARKDOWN 共 4 行                      展开    |  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |\n\n\n\n\n\n表头\n表头\n\n\n\n单元格\n单元格\n\n\n单元格\n单元格\n\n\n\n-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。\n          MARKDOWN 共 4 行                      展开    | 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |\n\n\n\n\n\n左对齐\n右对齐\n居中对齐\n\n\n\n单元格\n单元格\n单元格\n\n\n单元格\n单元格\n单元格\n\n\n\nMarkdown转义符显示特定的符号需要使用转义字符\\\n          MARKDOWN 共 12 行                      展开    \\\\   反斜线\\`   反引号\\*   星号\\_   下划线\\{}  花括号\\[]  方括号\\()  小括号\\#   井字号\\+   加号\\-   减号\\.   英文句点   感叹号\n\n\\   反斜线`   反引号*   星号_   下划线{}  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点   感叹号\n\n3.Markdown编辑与转化Markdown编辑使用vscode即可进行一般的编辑\n\n图床建议使用sm.ms^建议或github^提醒\n图床管理推荐PicGo\nMarkdown转化右键菜单中选择转化为word或html\n\n4.Markdown进阶用法警告：这些方法不一定在所有地方都适用\nHtml插入Html\n          HTML 共 1 行                      展开    &lt;font color=\"red\"&gt;红色&lt;/font&gt;\n红色\n字体颜色(1). html版如上文展示\n(2). latex版          MARKDOWN 共 1 行                      展开    $\\color{red}{红色}$\n\n红色\n预览时支持，转换时不支持\n如果在html文件下没有正确显示是一件十分正常的事\n播放视频只要有视频源就可以播放\nB站提供嵌入代码\n          HTML 共 1 行                      展开    &lt;iframe src=\"https://player.bilibili.com/player.html?aid=815603474&amp;bvid=BV1kG4y1q7Dy&amp;cid=835029171&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"&gt; &lt;/iframe&gt;\n\n \n\n进行优化后\n          HTML 共 1 行                      展开    &lt;iframe src=\"https://player.bilibili.com/player.html?aid=815603474&amp;bvid=BV1kG4y1q7Dy&amp;cid=835029171&amp;page=1&amp;page=1&amp;high_quality=1&amp;danmaku=0\" allowfullscreen=\"allowfullscreen\" width=\"100%\" height=\"500\" scrolling=\"no\" frameborder=\"0\" sandbox=\"allow-top-navigation allow-same-origin allow-forms allow-scripts\"&gt; &lt;/iframe&gt;\n\n \n\n在转换为word时会无视视频\nlatexmarkdown支持latex，但不同软件兼容性不同，请不要过度依赖\n","categories":["学习"],"tags":["markdown","网页"]},{"title":"素数的判断","url":"/2022/10/12/%E7%B4%A0%E6%95%B0%E7%9A%84%E5%88%A4%E6%96%AD/","content":"素数的常用判断方法\n\n\n\n超级普通法\n\n只是利用了素数的定义时间复杂度\n          C++ 共 8 行                      展开    bool Prime0(int x){    if(x==1) return 0;//排除特殊    if(x==2||x==3) return 1;    for(int i=2,i&lt;=x;i++)      if(x%i==0) return 0;//不是    return 1;             //是}\n弊端：这个就不用说了吧\n标准常用法\n\n针对基础解法只是将单个时间复杂度降为（即去除了一部分重复的不必要的东西）\n          C++ 共 7 行                      展开    bool Prime1(int x)   //由于时间复杂度太高 ，只判断单个数{    if(x==1) return 0; \tfor(int i=2;i&lt;=sqrt(x);i++) \t   if(x%i==0) return 0;//不是质数\treturn 1;              //是质数 }\n\n弊端同上\n爱拉托斯特尼筛法\n\n原理：素数的倍数一定不是素数时间复杂度为\n          C++ 共 11 行                      展开    int prime[mx];void Prime2()    //时间复杂度 O(n*lglgn){\tfor (int i=0;i&lt;mx;i++) prime[i]=1;//初始化，全体为合数\tprime[0]=prime[1]=0;//排除特殊\tfor (int i=2;i&lt;mx;i++)\t{\t\tif(!prime[i]) continue;\t\tfor (int j=i*2,j&lt;mx;j+=i) prime[j]=0;//将i倍数标记为合数 \t }  } \n\n弊端：一个数会被筛很多次\n线性筛法(欧拉筛）\n\n有点复杂\n原理：一个合数只会被他最小的质数因子筛去一次时间复杂度约为(抵消后）\n          C++ 共 15 行                      展开    int vis[mx]，prime[mx];void prime3()     //复杂度 O(n) {\tint cnt=0;    vis[1]=1;     //排除特殊情况1\tfor(int i=2;i&lt;=n;i++)\t{\t\tif(!vis[i]) prime[cnt++]=i;\t\tfor (int j=0;j&lt;cnt&amp;&amp;i*prime[j]&lt;=n;j++)\t\t{\t\t\tvis[i*prime[j]]=1;     //倍数去除\t\t\tif(i%prime[j]==0) break;   //去重\t\t} \t} } \n\n弊端：为了判断一个大数是否是素数必须从从头开始扫描，而且空间代价也受不了，故不能离散的判断\n其它\n\n证明：令x≥1，将大于等于5的自然数表示如下：······ 6x-1，6x，6x+1，6x+2，6x+3，6x+4，6x+5，6(x+1），6(x+1)+1 ······则可以得到，不在6的倍数两侧，即不在6x两侧的数为6x+2，6x+3，6x+4，等于2(3x+1)，3(2x+1)，2(3x+2)，包括6x本身，它们一定不是素数\n由此我们可以得到：素数要出现只可能出现在6x的相邻两侧。\n注意：在的倍数相邻两侧并不是一定就是质数。\n此时判断质数可以6个为单元快进，即将方法1循环中i++步长加大为6，加快判断速度。循环中只需要考虑6i-1和6i+1的情况，即循环的步长可以定为6，每次判断循环变量k和k+2的情况即可，理论上讲整体速度应该会是方法1的3倍。（从这篇文章转载）\n时间复杂度\n          C++ 共 9 行                      展开    bool Prime4(int n){    if(n==1) return 0;    if(n==2||n==3) return 1;    //特判    if(n%6!=1&amp;&amp;n%6!=5) return 0;    for(register int i=5;i*i&lt;=n;i+=6)        if(n%i==0||n%(i+2)==0) return false;    return true;}\n弊端：只是一部分取巧，没有根本解决问题\nmiller rabin算法\n\n作用：大概率地判断一个数是否为素数基础理论(1) 费马小定理(2) 二次探测的证明\n具体流程(1) 直接判断偶数和0，1，2 \n(2)设要测试的数为x，再取一个较小的质数a，设s,t，满足\n(3)计算出，然后不断地平方并且进行二次探测（进行s次）\n(4)根据费马小定理，若最终，则x为合数\n(5)多次取不同a测试，提高正确性\n时间复杂度都是玄学\n(1) 出错概率为（我也不知道为什么）\n(2) 可能是过程太复杂，没有找到关于它的时间复杂度的文章\n注意(1) a越多正确率越高(2) 当a取小于30的所有素数时，int范围的数不会出错(3) 由于数据量原因，要使用快速乘和快速幂\n代码（附测试）          C++ 共 63 行                      展开    #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int prime[10]={2,3,5,7,11,13,17,19,23,29};typedef long long ll;ll Quick_Multiply(ll a,ll b,ll c)   //快速积 {\tll ans=0,res=a;\twhile(b)\t{\t\tif(b&amp;1)\t\t  ans=(ans+res)%c;\t\tres=(res+res)%c;\t\tb&gt;&gt;=1;\t}\treturn ans;}ll Quick_Power(ll a,ll b,ll c)   //快速幂{\tll ans=1,res=a;\twhile(b)\t{\t\tif(b&amp;1)\t\t  ans=Quick_Multiply(ans,res,c);\t    res=Quick_Multiply(res,res,c);\t    b&gt;&gt;=1;\t}\treturn ans;} bool Miller_Rabin(ll x){\tll s=0,t=x-1,k;\tif(x==2) return 1;\tif(x&lt;2||!(x&amp;1)) return 0;  //排除偶数，0，1\twhile(!(t&amp;1))              //将x分解为(2^s)*t的样子 \t{\t\ts++;\t\tt&gt;&gt;=1;\t} \tfor(int i=1;i&lt;10&amp;&amp;prime[i]&lt;x;i++)   //开始测试 \t{\t\tint a=prime[i];\t\tll b=Quick_Power(a,t,x);        //计算a^t \t\tfor (int j=1;j&lt;=s;++j)          //s次平方 \t\t{\t\t\tk=Quick_Multiply(b,b,x);    //求b的平方 \t\t\tif(k==1&amp;&amp;b!=1&amp;&amp;b!=x-1)      //二次探求判断 \t\t\t  return 0;\t\t\tb=k;\t\t}\t\tif(b!=1) return 0;              //费马小定理判断 \t}\treturn 1;                           //多次实验，是素数 }int main(){\tll x;\tscanf(\"%lld\",&amp;x);\tif(Miller_Rabin(x)) printf(\"Yes\");\telse printf(\"No\");\treturn 0;}\n注：本算法难点在于两个定理和快速乘和快速幂\n参考资料（复制粘贴）\nhttps://blog.csdn.net/ltyqljhwcm/article/details/53045840\nhttps://blog.csdn.net/forever_dreams/article/details/82314237\nhttps://www.luogu.org/problemnew/solution/P3383\n","categories":["学习"],"tags":["数学"]}]