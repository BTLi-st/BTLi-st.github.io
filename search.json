[{"title":"markdown教程","url":"/2022/10/12/markdown%E6%95%99%E7%A8%8B/","content":"\nMarkDown入门指南\n\n1.关于MarkDownMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n优点\n轻量，码量极低\n简单，易于上手\n扩展，兼容Html和LaTeX\n\n缺点\n功能少，自定义程度低  \n\n例如原生不支持播放视频\n\n\n标准不统一，不同解释器兼容性不同 \n\n不是所有都支持完整Html和LaTex\n\n\n\n2.简单上手注意：本段只涉及MarkDown自带语法，在所有编辑器上均可正常显示\nMarkDown 标题Markdown 标题有两种格式。\n(1). 使用 = 和 - 标记一级和二级标题这是一级标题=================这是二级标题-----------------\n\n\n这是一级标题这是二级标题\n(2). 使用 # 号标记# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题\n\n\n一级标题二级标题三级标题四级标题五级标题六级标题\nMarkDown 段落格式Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。当然也可以在段落后面使用一个空行来表示重新开始一个段落。\nMarkDown 字体格式(1). MarkDown字体*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___\n\n\n斜体文本斜体文本粗体文本粗体文本粗斜体文本粗斜体文本  \n\n(2). 删除线~~删除线~~\n\n删除线\n\n(3). 分隔线**** * ******- - -----------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(4). 脚注文本[^要注明的文本][^要注明的文本]: 脚注\n\n\n文本 ^1\n\n\n\nMardown 列表(1). 无序列表* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项\n\n\n\n第一项\n第二项\n第三项\n\n\n\n\n第一项\n第二项\n第三项\n\n\n\n\n第一项\n第二项\n第三项\n\n\n(2). 有序列表1. 第一项2. 第二项3. 第三项\n\n\n\n第一项\n第二项\n第三项\n\n\n(3). 列表嵌套列表嵌套只需在子列表中的选项前面添加两个或四个空格即可\n1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素\n\n\n\n第一项：\n第一项嵌套的第一个元素\n第一项嵌套的第二个元素\n\n\n第二项：\n第二项嵌套的第一个元素\n第二项嵌套的第二个元素\n\n\n\n\nMarkdown 区块&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套\n\n\n最外层\n\n第一层嵌套\n\n第二层嵌套\n\n\n\n在区块中可使用列表，同理，在列表中可使用区块\nMarkdown 代码(1). 在段落中显示代码片段`代码片段`\n\n\nprint()函数\n\n(2). 代码区块使用一个tab键或四个空格键\nprint('Hello World!')\n\n使用```包裹\n```语言名称（可选）内容\n```pythonprint('Hello World!')\n\nMarkdown链接[链接名称](链接地址)或&lt;链接地址&gt;\n\n\npython课程资源https://www.bilibili.com/\n\nMarkdown图片![alt text(替代文字)](图片地址)或![alt text(替代文字)](图片地址 \"可选标题\")\n\n\n\n\n替代文字会在图片无法加载时出现\n图片可以带上链接\n![alt text(替代文字)](图片地址)](链接地址)\n\n\n\n\nMarkdown列表|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |\n\n\n\n\n\n表头\n表头\n\n\n\n单元格\n单元格\n\n\n单元格\n单元格\n\n\n\n-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。\n| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |\n\n\n\n\n\n左对齐\n右对齐\n居中对齐\n\n\n\n单元格\n单元格\n单元格\n\n\n单元格\n单元格\n单元格\n\n\n\nMarkdown转义符显示特定的符号需要使用转义字符\\\n\\\\   反斜线\\`   反引号\\*   星号\\_   下划线\\{}  花括号\\[]  方括号\\()  小括号\\#   井字号\\+   加号\\-   减号\\.   英文句点   感叹号\n\n\\   反斜线`   反引号*   星号_   下划线{}  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点   感叹号\n\n3.Markdown编辑与转化Markdown编辑使用vscode即可进行一般的编辑\n\n图床建议使用sm.ms^建议或github^提醒\n图床管理推荐PicGo\nMarkdown转化右键菜单中选择转化为word或html\n\n4.Markdown进阶用法警告：这些方法不一定在所有地方都适用\nHtml插入Html\n&lt;font color=\"red\"&gt;红色&lt;/font&gt;\n红色\n字体颜色(1). html版如上文展示\n(2). latex版$$\\color{red}{红色}$$\n\n红色\n预览时支持，转换时不支持\n如果在html文件下没有正确显示是一件十分正常的事\n播放视频只要有视频源就可以播放\nB站提供嵌入代码\n&lt;iframe src=\"https://player.bilibili.com/player.html?aid=815603474&amp;bvid=BV1kG4y1q7Dy&amp;cid=835029171&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"&gt; &lt;/iframe&gt;\n\n \n\n进行优化后\n&lt;iframe src=\"https://player.bilibili.com/player.html?aid=815603474&amp;bvid=BV1kG4y1q7Dy&amp;cid=835029171&amp;page=1&amp;page=1&amp;high_quality=1&amp;danmaku=0\" allowfullscreen=\"allowfullscreen\" width=\"100%\" height=\"500\" scrolling=\"no\" frameborder=\"0\" sandbox=\"allow-top-navigation allow-same-origin allow-forms allow-scripts\"&gt; &lt;/iframe&gt;\n\n \n\n在转换为word时会无视视频\nlatexmarkdown支持latex，但不同软件兼容性不同，请不要过度依赖\n","categories":["学习"],"tags":["markdown","网页"]},{"title":"素数的判断","url":"/2022/10/12/%E7%B4%A0%E6%95%B0%E7%9A%84%E5%88%A4%E6%96%AD/","content":"素数的常用判断方法\n\n\n\n超级普通法\n\n只是利用了素数的定义时间复杂度\nbool Prime0(int x){    if(x==1) return 0;//排除特殊    if(x==2||x==3) return 1;    for(int i=2,i&lt;=x;i++)      if(x%i==0) return 0;//不是    return 1;             //是}\n弊端：这个就不用说了吧\n标准常用法\n\n针对基础解法只是将单个时间复杂度降为（即去除了一部分重复的不必要的东西）\nbool Prime1(int x)   //由于时间复杂度太高 ，只判断单个数{    if(x==1) return 0; \tfor(int i=2;i&lt;=sqrt(x);i++) \t   if(x%i==0) return 0;//不是质数\treturn 1;              //是质数 }\n\n弊端同上\n爱拉托斯特尼筛法\n\n原理：素数的倍数一定不是素数时间复杂度为\nint prime[mx];void Prime2()    //时间复杂度 O(n*lglgn){\tfor (int i=0;i&lt;mx;i++) prime[i]=1;//初始化，全体为合数\tprime[0]=prime[1]=0;//排除特殊\tfor (int i=2;i&lt;mx;i++)\t{\t\tif(!prime[i]) continue;\t\tfor (int j=i*2,j&lt;mx;j+=i) prime[j]=0;//将i倍数标记为合数 \t }  } \n\n弊端：一个数会被筛很多次\n线性筛法(欧拉筛）\n\n有点复杂\n原理：一个合数只会被他最小的质数因子筛去一次时间复杂度约为(抵消后）\nint vis[mx]，prime[mx];void prime3()     //复杂度 O(n) {\tint cnt=0;    vis[1]=1;     //排除特殊情况1\tfor(int i=2;i&lt;=n;i++)\t{\t\tif(!vis[i]) prime[cnt++]=i;\t\tfor (int j=0;j&lt;cnt&amp;&amp;i*prime[j]&lt;=n;j++)\t\t{\t\t\tvis[i*prime[j]]=1;     //倍数去除\t\t\tif(i%prime[j]==0) break;   //去重\t\t} \t} } \n\n弊端：为了判断一个大数是否是素数必须从从头开始扫描，而且空间代价也受不了，故不能离散的判断\n其它\n\n证明：令x≥1，将大于等于5的自然数表示如下：······ 6x-1，6x，6x+1，6x+2，6x+3，6x+4，6x+5，6(x+1），6(x+1)+1 ······则可以得到，不在6的倍数两侧，即不在6x两侧的数为6x+2，6x+3，6x+4，等于2(3x+1)，3(2x+1)，2(3x+2)，包括6x本身，它们一定不是素数\n由此我们可以得到：素数要出现只可能出现在6x的相邻两侧。\n注意：在的倍数相邻两侧并不是一定就是质数。\n此时判断质数可以6个为单元快进，即将方法1循环中i++步长加大为6，加快判断速度。循环中只需要考虑6i-1和6i+1的情况，即循环的步长可以定为6，每次判断循环变量k和k+2的情况即可，理论上讲整体速度应该会是方法1的3倍。（从这篇文章转载）\n时间复杂度\nbool Prime4(int n){    if(n==1) return 0;    if(n==2||n==3) return 1;    //特判    if(n%6!=1&amp;&amp;n%6!=5) return 0;    for(register int i=5;i*i&lt;=n;i+=6)        if(n%i==0||n%(i+2)==0) return false;    return true;}\n弊端：只是一部分取巧，没有根本解决问题\nmiller rabin算法\n\n作用：大概率地判断一个数是否为素数基础理论(1) 费马小定理(2) 二次探测的证明\n具体流程(1) 直接判断偶数和0，1，2 \n(2)设要测试的数为x，再取一个较小的质数a，设s,t，满足\n(3)计算出，然后不断地平方并且进行二次探测（进行s次）\n(4)根据费马小定理，若最终，则x为合数\n(5)多次取不同a测试，提高正确性\n时间复杂度都是玄学\n(1) 出错概率为（我也不知道为什么）\n(2) 可能是过程太复杂，没有找到关于它的时间复杂度的文章\n注意(1) a越多正确率越高(2) 当a取小于30的所有素数时，int范围的数不会出错(3) 由于数据量原因，要使用快速乘和快速幂\n代码（附测试）#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int prime[10]={2,3,5,7,11,13,17,19,23,29};typedef long long ll;ll Quick_Multiply(ll a,ll b,ll c)   //快速积 {\tll ans=0,res=a;\twhile(b)\t{\t\tif(b&amp;1)\t\t  ans=(ans+res)%c;\t\tres=(res+res)%c;\t\tb&gt;&gt;=1;\t}\treturn ans;}ll Quick_Power(ll a,ll b,ll c)   //快速幂{\tll ans=1,res=a;\twhile(b)\t{\t\tif(b&amp;1)\t\t  ans=Quick_Multiply(ans,res,c);\t    res=Quick_Multiply(res,res,c);\t    b&gt;&gt;=1;\t}\treturn ans;} bool Miller_Rabin(ll x){\tll s=0,t=x-1,k;\tif(x==2) return 1;\tif(x&lt;2||!(x&amp;1)) return 0;  //排除偶数，0，1\twhile(!(t&amp;1))              //将x分解为(2^s)*t的样子 \t{\t\ts++;\t\tt&gt;&gt;=1;\t} \tfor(int i=1;i&lt;10&amp;&amp;prime[i]&lt;x;i++)   //开始测试 \t{\t\tint a=prime[i];\t\tll b=Quick_Power(a,t,x);        //计算a^t \t\tfor (int j=1;j&lt;=s;++j)          //s次平方 \t\t{\t\t\tk=Quick_Multiply(b,b,x);    //求b的平方 \t\t\tif(k==1&amp;&amp;b!=1&amp;&amp;b!=x-1)      //二次探求判断 \t\t\t  return 0;\t\t\tb=k;\t\t}\t\tif(b!=1) return 0;              //费马小定理判断 \t}\treturn 1;                           //多次实验，是素数 }int main(){\tll x;\tscanf(\"%lld\",&amp;x);\tif(Miller_Rabin(x)) printf(\"Yes\");\telse printf(\"No\");\treturn 0;}\n注：本算法难点在于两个定理和快速乘和快速幂\n参考资料（复制粘贴）\nhttps://blog.csdn.net/ltyqljhwcm/article/details/53045840\nhttps://blog.csdn.net/forever_dreams/article/details/82314237\nhttps://www.luogu.org/problemnew/solution/P3383\n","categories":["学习"],"tags":["数学"]},{"title":"test","url":"/2022/10/20/test/","content":"\n  02eccf08e43c12920d7fd130715026bc4056f6ae7867f143ce692c46bea1e0263c44b7956a6fd7f03cbaf15cd2b10f1eebb15212b80c16952b52d5b73ad0dccf49fe0d12b1f11c7e67e1eedcd6adfce8808a1f15e0a62b47e98c0e70bea4db396eec1e360a83f5aedf89bafb301da38b0f03de4fcbe49d664e6b599f0c68de04490528a4baa255157d64a8073812bd2f568acaa387687908053c87cd3e06dc10\n  \n    \n      \n      \n        请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n      \n    \n  \n\n","categories":["测试"],"tags":["加密"]},{"title":"题解 P1160 【队列安排】","url":"/2022/11/12/%E9%A2%98%E8%A7%A3-P1160-%E3%80%90%E9%98%9F%E5%88%97%E5%AE%89%E6%8E%92%E3%80%91/","content":"高中时期的旧题解\n\n本蒟蒻第一篇题解若有错误，请谅解\n\n这道题是一道典型的模拟题，故本蒟蒻第一个想到的就是用数组（太年轻），然后每加一个同学，就把他后面的同学位置整体向后挪，将他放进去，然后\n就没有然后了···对于N，M ≤ 100000和这个无比粗暴的方法，不TLE就是奇迹\n\n妄想偷懒不行，只能好好分析一下题\n稍加观察可以看出，这是一个链式结构，移动同学肯定是不行的（时间复杂度太高），那么，只能对他们间的关系下手了\n我们可以把每相邻的的两个同学想象成他们牵着手（如图）既然如此，我们就只需要改动左右手指向的同学就可以了定义一个结构体\nstruct T{    int l,r;        //每个同学的“左右手” }t[mx]={0};\n现在我们就手动模拟一下加入同学（以右边为例）将编号为J的同学加入编号为i的同学右边\n第一步 J的右手牵I右手牵的同学\nt[j].r=t[i].r;\n第二步 J的左手牵I\nt[j].l=i;\n\n第三步 I的右手牵J\nt[i].r=j;\n\n第四步 J右手牵的同学的左手牵J注意：此时I的右手已经不牵原来那个同学了\nt[t[j].r].l=j;\n\n此时J就加入链当中了\n左边同理\n加入函数如下\nvoid add(int i,int k,int f)       //新增同学 {    if(f==1)         //右     {        t[k].r=t[i].r;        t[k].l=i;         t[i].r=k;        t[t[k].r].l=k;    }    else             //左    {        t[k].r=i;        t[k].l=t[i].l;        t[i].l=k;        t[t[k].l].r=k;    }}\n\n\n\n接下来是移除\n我们虽然也可以用上面方法来删除\n不过我用的是另一种方法（主要是懒）\n我们可以给每个同学一个标记，标记了的将不会输出\nstruct T{    int l,r;        //每个同学的“左右手” \tint d;          //表示同学是否输出 }t[mx]={0};\n结构体\nwhile(m--)    {        cin&gt;&gt;x;           //要删去的同学        t[x].d=1;         //将该同学标记为不输出     }\n标记\n\n接下来是细节问题链的初始化如果我们将1同学先输入进去\nt[1].l=1,t[1].r=1;\n因为没有其他同学只能自己牵自己（紧紧抱住弱小的自己）\n但如果这样，到输出时就有一个问题（以样例为例）找不到开头！\n这时我们就要在初始化时动些手脚\nt[0].r=0,t[0].l=0;add(0,1,1);\n定义个0同学链将变成这样我们只要从0的右手牵的同学开始输出，再到0结束就行了\n输出代码\nfor (int i=t[0].r;i;i=t[i].r){    if (t[i].d==0)    //输出未标记的       cout&lt;&lt;i&lt;&lt;\" \";}\n\n\n\n纯代码#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;const int mx=1e5+10;int n,m;struct T{    int l,r;        //每个同学的“左右手” \tint d;          //表示同学是否输出 }t[mx]={0};void add(int i,int k,int f)       //新增同学 {    if(f==1)         //左     {        t[k].r=t[i].r;        t[k].l=i;         t[i].r=k;        t[t[k].r].l=k;    }    else             //右     {        t[k].r=i;        t[k].l=t[i].l;        t[i].l=k;        t[t[k].l].r=k;    }}int main(){    int x,k,f;    cin&gt;&gt;n;    t[0].r=0,t[0].l=0;    add(0,1,1);    for (int i=2;i&lt;=n;i++)    {        cin&gt;&gt;x&gt;&gt;f;        add(x,i,f);    }    cin&gt;&gt;m;    while(m--)    {        cin&gt;&gt;x;        t[x].d=1;         //将该同学标记为不输出     }    for (int i=t[0].r;i;i=t[i].r)    {        if (t[i].d==0)    //输出未标记的           cout&lt;&lt;i&lt;&lt;\" \";    }    return 0;}\n","categories":["学习"],"tags":["题解","洛谷"]},{"title":"题解 P1311 【选择客栈】","url":"/2022/11/12/%E9%A2%98%E8%A7%A3-P1311-%E3%80%90%E9%80%89%E6%8B%A9%E5%AE%A2%E6%A0%88%E3%80%91/","content":"高中时期一篇没有过的旧题解，但我依然觉得这是我写过最好的一篇题解\n\n蒟蒻的第二篇题解（原来长时间不交还是要扣分的）\n\nOK，进入正题。\n看到此题，不知有没有人像我一样匆忙建立两个数组money[200005]和color[2000005]来储存客栈的价格和颜色。然后，使用无比暴力的方法进行时间复杂度为的计算。随后，听取声一片……\n在经历了一次（其实不止一次）的打击后，我开始仔细审题。可以看出来，减少时间的要点就是快速的处理颜色问题。显然用i++类的方法是极其困难的。其实计算时我们只需要符合条件的客栈的和，由此可知：我们只用一个数组储存各个颜色客栈的和就对了。\n那么该如何储存呢?我们一共需要两个客栈，一个开始，一个结束。由于读入时是以由前到后的顺序储存的，我们只能知道它前面的数据。为了减少循环，我们就用后一个客栈，加上前面符合客栈的个数就行了。\nint c[200005][55]//第一个下标为序号，第二个为颜色\n显然我们没必要开如此大的空间。\n我们第一个下标只需要两种情况，当前符合情况的和当前不符合情况的。既然如此，我们就以可以使用的咖啡馆为界（即money[i]&lt;=p])为界，在遇到新的咖啡馆时，再刷新数组，就可以解决时间问题了。\nfor (int i=1;i&lt;=n;i++)\t{\t\tscanf(\"%d%d\",&amp;color,&amp;money);//输入\t\tc[1][color]++;//对应颜色的不可用的和+1\t\tif(money&lt;=p)  //新的咖啡馆\t\t{\t\t\tfor (int j=0;j&lt;k;j++)//全部更新\t\t\t{\t\t\t\tc[0][j]+=c[1][j];//此时不可用的也可用了\t\t\t\tc[1][j]=0;//不可用的清零\t\t\t}\t\t\tcnt--;//重点\t\t}\t\tcnt+=c[0][color];//增加方案\t}\n注意当我们遇到新的符合条件的咖啡馆的时候，符合条件的客栈的数量是包括了它本身的，故我们cnt的值减1。\n当经历了一波三折，无数次失败后，我们最终只用了一个大小110的数组，时间复杂度也降到了最坏情况下。如此此题就了。\n原代码奉上#include&lt;cstdio&gt;using namespace std;int n,k,p,cnt=0,c[2][55],color,money;int main(){\tscanf(\"%d%d%d\",&amp;n,&amp;k,&amp;p);\tfor (int i=1;i&lt;=n;i++)\t{\t\tscanf(\"%d%d\",&amp;color,&amp;money);\t\tc[1][color]++;\t\tif(money&lt;=p)\t\t{\t\t\tfor (int j=0;j&lt;k;j++)\t\t\t{\t\t\t\tc[0][j]+=c[1][j];\t\t\t\tc[1][j]=0;\t\t\t}\t\t\tcnt--;\t\t}\t\tcnt+=c[0][color];\t}\tprintf(\"%d\",cnt);\treturn 0;}\n","categories":["学习"],"tags":["题解","洛谷"]},{"title":"题解 P1312 【Mayan游戏】","url":"/2022/11/12/%E9%A2%98%E8%A7%A3-P1312-%E3%80%90Mayan%E6%B8%B8%E6%88%8F%E3%80%91/","content":"高中时期的旧题解\n\n题解第一次过了一道Day1最后一题，心中还是有点激动。\n\n这道题目空间小，时间多，由此可见是一道码量极大的题。\n既然如此，我们就将它拆分一下。\n\n\n输入\n\n本题的输入是第一个坑，我开始把(0,0)的位置看错了，于是后面直接崩溃。题中输入时横着输入的，那么我们要处理一下\nvoid in(){\tint a;\tfor (int i=0;i&lt;5;i++)  //先是横坐标\t  for (int j=0;;j++)   //后是纵坐标（坑）\t  {\t  \tscanf(\"%d\",&amp;a);\t  \tif(a) mp[i][j]=a;\t  \telse break;\t  }}\n题目中讲到，遇到0就换一列。但是注意如果1列的7行都有数字，输入时依然会有0，故我们不能自动换列（60分的惨痛经历）\n\n掉落\n\n掉落部分相对比较简单，我们只需要把所有方块自下而上得遍历，检查它们下面空方块就行了。\nvoid down(){\tint m;\tfor (int i=0;i&lt;5;i++)//自下而上 \t{\t\tfor (int j=1;j&lt;7;j++)\t\t{\t\t\tif(mp[i][j])//这个方块有颜色 \t\t\t{\t\t\t\tm=0;\t\t\t\twhile(j-m-1&gt;=0 &amp;&amp; !mp[i][j-m-1]) m++;//寻找最下面的空方块 \t\t\t\tif(m) mp[i][j-m]=mp[i][j],mp[i][j]=0;//下移 \t\t\t}\t\t}\t} }\n这个步骤没有什么大坑，就是下掉时防止越界。\n\n清除\n\n清除部分要特别注意题目中的情况。\n由图5可知，我们不能遇到三个连块就直接消除，可能会无法完全消除。\n那么，我们需要另一个结构体\nstruct mem{\tint x,y;}me[100];\n在检测时，我们记录需要清除的方块，最后再一起清除。\nbool clear(){\tint t=0;//计数器 \tfor (int i=0;i&lt;5;i++)\t  for (int j=0;j&lt;7;j++)\t  {\t  \tif(mp[i][j])\t  \t{\t  \t\tif(i-1&gt;=0 &amp;&amp; i+1&lt;=4 &amp;&amp; mp[i-1][j]==mp[i][j] &amp;&amp; mp[i+1][j]==mp[i][j])//横向 \t  \t    {\t  \t\t    me[++t].x=i-1,me[t].y=j;\t  \t  \t    me[++t].x=i,me[t].y=j;\t  \t\t    me[++t].x=i+1,me[t].y=j;//储存 \t\t    }\t\t    if(j-1&gt;=0 &amp;&amp; j+1&lt;=6 &amp;&amp; mp[i][j-1]==mp[i][j] &amp;&amp; mp[i][j+1]==mp[i][j])//纵向 \t\t    {\t\t\t    me[++t].x=i,me[t].y=j-1;\t  \t\t    me[++t].x=i,me[t].y=j;\t  \t\t    me[++t].x=i,me[t].y=j+1;\t\t    }\t\t}\t  \t\t  }\tif(t)//有需要清除的 \t  for (int i=1;i&lt;=t;i++)\t    mp[me[i].x][me[i].y]=0;//清除 \telse return 0;//未清除 \treturn 1;//清除了 }\n注意，清除过后可能有掉落的，所以要返回一个值，表示要掉落一次。\n\n移动\n\n移动是很简单的，类似于交换a,b。最后进行掉落和清除。\nvoid mo(int x,int y,int d){\tint t=mp[x][y];\tmp[x][y]=mp[x+d][y];\tmp[x+d][y]=t;//交换a,b \tdown();//掉落 \twhile(clear()) down();//若有清除，则掉落 }\n注意：当清除过后，可能又有掉落的，但是掉落后有可能有可以清除的，比如上面图4，所以我们要循环（开心消消乐）\n\n备份与恢复\n\n这一点就直接使用三维数组。\nvoid copy(int t){\tfor (int i=0;i&lt;5;i++)\t  for(int j=0;j&lt;7;j++)\t    memory[t][i][j]=mp[i][j];}void back(int t){\tfor (int i=0;i&lt;5;i++)\t  for(int j=0;j&lt;7;j++)\t    mp[i][j]=memory[t][i][j];}\n\n检查\n\n循环遍历，遇到有未清除的就返回。\nbool check(){\tfor (int i=0;i&lt;5;i++)\t  if(mp[i][0])\t    return 0;\treturn 1;}\n\n\ndfs\n\n剪枝的方法与其它题解差不多。\n\n\n由于我们是按字典序输出，所以从（0,0）开始向上向右遍历。\n\n\n\n\n每个方块向右边走时右边一定要没有方块，否则会与前面的方块路径重叠。\n\n\nvoid dfs(int step)//第几步 {\tif(check() &amp;&amp; step&lt;=n+1)//有符合条件的 \t{\t\tfor (int i=1;i&lt;=step-1;i++)\t\t{\t\t  \tprintf(\"%d %d %d\\n\",s[i].x,s[i].y,s[i].move);\t\t}\t\texit(0);//直接退出程序 \t}\tif (step==n+1)//超出最大步数 \t  return ;\tcopy(step);//备份 \tfor (int i=0;i&lt;5;i++)\t  for (int j=0;j&lt;7;j++)\t  {\t  \tif(mp[i][j])// 方块存在 \t  \t{\t  \t\tif(i-1&gt;=0 &amp;&amp; mp[i-1][j]==0)//向左 \t  \t    {\t  \t\t    s[step].x=i,s[step].y=j,s[step].move=-1;\t\t\t\tmo(i,j,-1);\t  \t\t    dfs(step+1);\t  \t\t    back(step);\t  \t\t    s[step].x=0,s[step].y=0,s[step].move=0;\t\t    }\t  \t    if (i+1&lt;5 &amp;&amp; mp[i+1][j]!=mp[i][j])//向右 \t  \t    {\t  \t\t    s[step].x=i,s[step].y=j,s[step].move=1;\t\t\t\tmo(i,j,1);\t  \t\t    dfs(step+1);\t  \t\t    back(step);\t  \t\t    s[step].x=0,s[step].y=0,s[step].move=0;\t\t    }\t\t}\t  }}\n那么，主体部分就完成了。\n\n关于调试对于一道这样的题，一次过是比较困难的，但是步骤这么多，一步一步调试是极其困难的（样例已经够恐怖了）那么，我们就可以写一个输出函数，利用文件输出，一步步输出，再检查。\nint out(){\tfor (int j=7;j&gt;=0;j--)\t{\t\tfor (int i=0;i&lt;5;i++)\t\t{\t\t\tif(mp[i][j]) printf(\"%d \",mp[i][j]);\t\t\telse printf(\"  \");\t\t} \t\tprintf(\"\\n\");\t}}\n当然，洛谷上交时记得去掉。\n\n总结总的来说，只要将这题分割成一个个小部分，就可以系统地解决问题。\n当然，码量高的后果就是调试难，建议大家一个函数一个函数排除问题，将包围圈逐渐缩小，就可以解决问题了。\n\n#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;int mp[10][10];struct mem{\tint x,y;}me[100];int memory[10][10][10];int n;struct st{\tint x,y,move;}s[10];bool clear(){\tint t=0;//计数器 \tfor (int i=0;i&lt;5;i++)\t  for (int j=0;j&lt;7;j++)\t  {\t  \tif(mp[i][j])\t  \t{\t  \t\tif(i-1&gt;=0 &amp;&amp; i+1&lt;=4 &amp;&amp; mp[i-1][j]==mp[i][j] &amp;&amp; mp[i+1][j]==mp[i][j])//横向 \t  \t    {\t  \t\t    me[++t].x=i-1,me[t].y=j;\t  \t  \t    me[++t].x=i,me[t].y=j;\t  \t\t    me[++t].x=i+1,me[t].y=j;//储存 \t\t    }\t\t    if(j-1&gt;=0 &amp;&amp; j+1&lt;=6 &amp;&amp; mp[i][j-1]==mp[i][j] &amp;&amp; mp[i][j+1]==mp[i][j])//纵向 \t\t    {\t\t\t    me[++t].x=i,me[t].y=j-1;\t  \t\t    me[++t].x=i,me[t].y=j;\t  \t\t    me[++t].x=i,me[t].y=j+1;\t\t    }\t\t}\t  \t\t  }\tif(t)//有需要清除的 \t  for (int i=1;i&lt;=t;i++)\t    mp[me[i].x][me[i].y]=0;//清除 \telse return 0;//未清除 \treturn 1;//清除了 }void down(){\tint m;\tfor (int i=0;i&lt;5;i++)//自下而上 \t{\t\tfor (int j=1;j&lt;7;j++)\t\t{\t\t\tif(mp[i][j])//这个方块有颜色 \t\t\t{\t\t\t\tm=0;\t\t\t\twhile(j-m-1&gt;=0 &amp;&amp; !mp[i][j-m-1]) m++;//寻找最下面的空方块 \t\t\t\tif(m) mp[i][j-m]=mp[i][j],mp[i][j]=0;//下移 \t\t\t}\t\t}\t} }void mo(int x,int y,int d){\tint t=mp[x][y];\tmp[x][y]=mp[x+d][y];\tmp[x+d][y]=t;//交换a,b \tdown();//掉落 \twhile(clear()) down();//若有清除，则掉落 }bool check(){\tfor (int i=0;i&lt;5;i++)\t  if(mp[i][0])\t    return 0;\treturn 1;}void copy(int t){\tfor (int i=0;i&lt;5;i++)\t  for(int j=0;j&lt;7;j++)\t    memory[t][i][j]=mp[i][j];}void back(int t){\tfor (int i=0;i&lt;5;i++)\t  for(int j=0;j&lt;7;j++)\t    mp[i][j]=memory[t][i][j];}void dfs(int step)//第几步 {\tif(check() &amp;&amp; step&lt;=n+1)//有符合条件的 \t{\t\tfor (int i=1;i&lt;=step-1;i++)\t\t{\t\t  \tprintf(\"%d %d %d\\n\",s[i].x,s[i].y,s[i].move);\t\t}\t\texit(0);//直接退出程序 \t}\tif (step==n+1)//超出最大步数 \t  return ;\tcopy(step);//备份 \tfor (int i=0;i&lt;5;i++)\t  for (int j=0;j&lt;7;j++)\t  {\t  \tif(mp[i][j])// 方块存在 \t  \t{\t  \t\tif(i-1&gt;=0 &amp;&amp; mp[i-1][j]==0)//向左 \t  \t    {\t  \t\t    s[step].x=i,s[step].y=j,s[step].move=-1;\t\t\t\tmo(i,j,-1);\t  \t\t    dfs(step+1);\t  \t\t    back(step);\t  \t\t    s[step].x=0,s[step].y=0,s[step].move=0;\t\t    }\t  \t    if (i+1&lt;5 &amp;&amp; mp[i+1][j]!=mp[i][j])//向右 \t  \t    {\t  \t\t    s[step].x=i,s[step].y=j,s[step].move=1;\t\t\t\tmo(i,j,1);\t  \t\t    dfs(step+1);\t  \t\t    back(step);\t  \t\t    s[step].x=0,s[step].y=0,s[step].move=0;\t\t    }\t\t}\t  }}void in(){\tint a;\tfor (int i=0;i&lt;5;i++)//先是横坐标 \t  for (int j=0;;j++)//后是纵坐标（注意这里有个坑） \t  {\t  \tscanf(\"%d\",&amp;a);\t  \tif(a) mp[i][j]=a;\t  \telse break;\t  }}int main(){\tscanf(\"%d\",&amp;n);\tin();\tdfs(1);\tprintf(\"-1\");\treturn 0;}\n\n\n\n军训时看到迷彩背心，突然想到一种更快的掉落方式。（心路历程：迷彩-&gt;一个个方块-&gt;开心消消乐-&gt;MAYAN游戏-&gt;更好的掉落方式）（我也不知道怎么想到的）\n从每一列的最下方开始搜索，记录每个实体方块是这一列第几个，将它移到这个位置就可以了。\nvoid drop(){\tfor(int i=0;i&lt;5;i++)\t{\t\tint c=0,m;\t\tfor(int j=0;j&lt;7;j++)\t\t{\t\t\tif(mp[i][j])\t\t\t  m=mp[i][j],mp[i][j]=0,mp[i][c]=m,c++;\t\t}\t}}\n注意要将方块先清空并把颜色（数字）寄存到一个变量里，因为这个方法并不知道是不是没有掉落，而是寻找每个方块应该在的位置，如果后清理的话，就会出现没有移动的方块消失的情况。\n这应该比循环找最下空方块快点吧（怎么感觉用时还变多了呢）\n","categories":["学习"],"tags":["题解","洛谷"]},{"title":"题解 P1514 【引水入城】","url":"/2022/11/12/%E9%A2%98%E8%A7%A3-P1514-%E3%80%90%E5%BC%95%E6%B0%B4%E5%85%A5%E5%9F%8E%E3%80%91/","content":"高中时期的旧题解\n\n看到其他大佬的各种题解，蒟蒻瑟瑟发抖。这道题一共有两个小问，很多大佬都想到用两次搜索，但鉴于本蒟蒻是一个懒惰的菜鸡，又不想去写什么bfs。于是，在经过一番激烈的挣扎后，该蒟蒻选择了——放弃。\n\n好了，回归正题，要只用一次搜索而且是dfs的话，肯定是要剪枝的（废话）。很多大佬也给出了各种奇妙的方式，比如对于靠近水的城市，如果它周围两个城市海拔都高于它的话，就不搜索。\n但是蒟蒻是一个很懒的人，于是他就想到了——记忆化搜索。\n根据大佬的证明，每个水库的所供给的靠近沙漠的城市一定是一个区间，那么我们可以储存每个城市所包含的区间（包括中间的城市）。当搜索到重复的城市时，我们只用知道它所可以供给的区间。一个城市所供给的区间就是附近海拔低于它的城市供给区间的并集。（怎么有种线段树的感觉…）\nvoid dfs(int a,int b){\tif(vis[a][b]) return ;//搜索过，直接返回 \tif(a==n) li[a][b].l=b,li[a][b].r=b;//靠近沙漠的区间初始化为自己 \tvis[a][b]=1;//标记访问  \tfor(int i=0;i&lt;4;i++)\t{\t\tint x=a+di[0][i],y=b+di[1][i];\t\tif(x&gt;0 &amp;&amp; x&lt;=n &amp;&amp; y&gt;0 &amp;&amp; y&lt;=m &amp;&amp; li[x][y].mp&lt;li[a][b].mp)\t\t{\t\t\tdfs(x,y);\t\t\tli[a][b].l=li[a][b].l&gt;li[x][y].l?li[x][y].l:li[a][b].l;//更新区间 \t\t\tli[a][b].r=li[a][b].r&gt;li[x][y].r?li[a][b].r:li[x][y].r;\t\t}\t}}\n之后就是关于第二小问，计算最少蓄水池，其实就是线段覆盖问题。\n\n1.我们其实按左端点排序就可以了，从小到大。\n\n\n2.记录目前覆盖区间的右端点，然后去记录所有左端点小于这个值的区间的最大右端点（就是贪心）。\n\n\n3.如果记录到最后的右端点值还是小于m的话，就直接加1（因为既然可以符合条件就一定可以覆盖。\n\nfor (int i=1;i&lt;=m;i++)         {            if (li[1][i].l&gt;m) break;//没有覆盖城市的蓄水池             if (li[1][i].l&lt;=1+maxv) tmp=max(tmp,li[1][i].r);//储存最大右区间             else            {                maxv=tmp;//更新总右区间                 ans++;//计数                 tmp=max(li[1][i].r,tmp);//更新             }              }\n\n\n好了，一遍dfs的方法就出来了，最长也就40ms左右。\n\nCode#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const int mx=600;struct line{\tint l,r;\tint mp;}li[mx][mx];bool vis[mx][mx],flag=1;int n,m,ans,k;int di[2][4]={{-1,1,0,0},{0,0,1,-1}};void dfs(int a,int b){\tif(vis[a][b]) return ;//搜索过，直接返回 \tif(a==n) li[a][b].l=b,li[a][b].r=b,k++;//靠近沙漠的区间初始化为自己 ,计数可以被运水的城市 \tvis[a][b]=1;//标记访问\tfor(int i=0;i&lt;4;i++)\t{\t\tint x=a+di[0][i],y=b+di[1][i];\t\tif(x&gt;0 &amp;&amp; x&lt;=n &amp;&amp; y&gt;0 &amp;&amp; y&lt;=m &amp;&amp; li[x][y].mp&lt;li[a][b].mp)\t\t{\t\t\tdfs(x,y);\t\t\tli[a][b].l=li[a][b].l&gt;li[x][y].l?li[x][y].l:li[a][b].l;//更新区间 \t\t\tli[a][b].r=li[a][b].r&gt;li[x][y].r?li[a][b].r:li[x][y].r;\t\t}\t}}bool cmp(line a,line b){\tif(a.l!=b.l) return a.l&lt;b.l;\telse return a.r&gt;b.r;}int main(){\tscanf(\"%d%d\",&amp;n,&amp;m);\tfor(int i=1;i&lt;=n;i++)\t  for(int j=1;j&lt;=m;j++)\t    scanf(\"%d\",&amp;li[i][j].mp),li[i][j].r=0,li[i][j].l=m+1;\tfor(int i=1;i&lt;=m;i++)\t  dfs(1,i);\tif(m!=k) flag=0,ans=m-k;//没有覆盖完 \tif(flag==1)\t{\t    printf(\"1\\n\");\t\tsort(li[1]+1,li[1]+1+m,cmp);\t\tint maxv=0,tmp=0;\t\tfor (int i=1;i&lt;=m;i++)         {            if (li[1][i].l&gt;m) break;//没有覆盖城市的蓄水池             if (li[1][i].l&lt;=1+maxv) tmp=max(tmp,li[1][i].r);//储存最大右区间             else            {                maxv=tmp;//更新总右区间                 ans++;//计数                 tmp=max(li[1][i].r,tmp);//更新             }              }        if(maxv!=m) ans++;\t}\telse printf(\"0\\n\");\tprintf(\"%d\",ans);\treturn 0;}\n","categories":["学习"],"tags":["题解","洛谷"]},{"title":"题解 P1736 【创意吃鱼法】","url":"/2022/11/12/%E9%A2%98%E8%A7%A3-P1736-%E3%80%90%E5%88%9B%E6%84%8F%E5%90%83%E9%B1%BC%E6%B3%95%E3%80%91/","content":"高中时期的旧题解\n\n在本蒟蒻与此题大战三回合后，终于A了这道题…果然是我太弱了吗这道题本身也不算太难，稍微暴力一点的方法也是可以过的。\n\n首先我们读题，题目翻译过来就是我们要输出最大符合条件正方形的边长，单纯一个个枚举多半是要超时的。其实对于一个点来说，我们只用了解它左上和右上的点的情况，再检索它横竖有没有1就可以了。那么我们先建一个结构体\nstruct fish{\tint mp;\tint num1;\tint num2;}f[mx][mx];\nnum1表示当它为右下端点时，最大正方形的边长，num2表示当它为左下端点时，最大正方形的边长。mp储存的就是01；接下来就是遍历啦\nfor(int i=1;i&lt;=n;i++)\t  for(int j=1;j&lt;=m;j++)\t  {\t\tif(f[i][j].mp==1) f[i][j].num1=1;//是1的至少边长为1 \t  \tif(f[i-1][j-1].mp==1 &amp;&amp; f[i][j].mp==1)//左上的点也为1 \t  \t{\t  \t\tf[i][j].num1=f[i-1][j-1].num1+1;//边长加1 \t  \t\tfor(int k=1;k&lt;f[i-1][j-1].num1+1;k++)//判断边是否合法 \t  \t\t{\t  \t\t\tif(f[i-k][j].mp==1 || f[i][j-k].mp==1)//有其它地方为1的 \t  \t\t\t{\t  \t\t\t\tf[i][j].num1=1;//重置为1\t  \t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t\tans=max(ans,f[i][j].num1);//更新答案 \t\t}\t  }\nnum2同理\nfor(int i=1;i&lt;=n;i++)\t  for(int j=m;j&gt;=1;j--)\t  {\t  \tif(f[i][j].mp==1) f[i][j].num2=1;\t  \tif(f[i-1][j+1].mp==1 &amp;&amp; f[i][j].mp==1)\t  \t{\t  \t\tf[i][j].num2=f[i-1][j+1].num2+1;\t  \t\tfor(int k=1;k&lt;f[i-1][j+1].num2+1;k++)\t  \t\t{\t  \t\t\tif(f[i-k][j].mp==1 || f[i][j+k].mp==1)\t  \t\t\t{\t  \t\t\t\tf[i][j].num2=1;\t  \t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t\tans=max(ans,f[i][j].num2);\t\t}\t  }\n好像完成了，交上去。\n\n后来在翻讨论帖时，有大佬提供了这样一组数据\n4 41 0 1 00 1 0 01 0 1 00 0 0 1\n答案为3。\n但如果像刚才一样计算的话，输出为2。\n在经过我仔细检查（询问大佬）之后，发现在检查时出了问题。\n不能直接重置为1，而要将它置位k。不然如果遇到上面这种数据时，而不是。\n顺便提一下，在计算num1时，我们可以将它与输入合在一起。因为计算当前点num1时只需要它左上的数据，而输入是从左到右，从上到下的。\nfor(int i=1;i&lt;=n;i++)\t  for(int j=1;j&lt;=m;j++)\t  {\t  \tscanf(\"%d\",&amp;f[i][j].mp);\t\tif(f[i][j].mp==1) f[i][j].num1=1;//是1的至少边长为1 \t  \tif(f[i-1][j-1].mp==1 &amp;&amp; f[i][j].mp==1)//左上的点也为1 \t  \t{\t  \t\tf[i][j].num1=f[i-1][j-1].num1+1;//边长加1 \t  \t\tfor(int k=1;k&lt;f[i-1][j-1].num1+1;k++)//判断边是否合法 \t  \t\t{\t  \t\t\tif(f[i-k][j].mp==1 || f[i][j-k].mp==1)//有其它地方为1的 \t  \t\t\t{\t  \t\t\t\tf[i][j].num1=k;//存储此时最大边长 \t  \t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t\tans=max(ans,f[i][j].num1);//更新答案 \t\t}\t  }\n如此就可以AC了。\n\n完整代码#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;using namespace std;const int mx=3000;int n,m;int mp;int ans;struct fish{\tint mp;\tint num1;\tint num2;}f[mx][mx];int main(){\tscanf(\"%d%d\",&amp;n,&amp;m);\tfor(int i=1;i&lt;=n;i++)\t  for(int j=1;j&lt;=m;j++)\t  {\t  \tscanf(\"%d\",&amp;f[i][j].mp);\t\tif(f[i][j].mp==1) f[i][j].num1=1;//是1的至少边长为1 \t  \tif(f[i-1][j-1].mp==1 &amp;&amp; f[i][j].mp==1)//左上的点也为1 \t  \t{\t  \t\tf[i][j].num1=f[i-1][j-1].num1+1;//边长加1 \t  \t\tfor(int k=1;k&lt;f[i-1][j-1].num1+1;k++)//判断边是否合法 \t  \t\t{\t  \t\t\tif(f[i-k][j].mp==1 || f[i][j-k].mp==1)//有其它地方为1的 \t  \t\t\t{\t  \t\t\t\tf[i][j].num1=k;//存储此时最大边长 \t  \t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t\tans=max(ans,f[i][j].num1);//更新答案 \t\t}\t  }\tfor(int i=1;i&lt;=n;i++)\t  for(int j=m;j&gt;=1;j--)\t  {\t  \tif(f[i][j].mp==1) f[i][j].num2=1;\t  \tif(f[i-1][j+1].mp==1 &amp;&amp; f[i][j].mp==1)\t  \t{\t  \t\tf[i][j].num2=f[i-1][j+1].num2+1;\t  \t\tfor(int k=1;k&lt;f[i-1][j+1].num2+1;k++)\t  \t\t{\t  \t\t\tif(f[i-k][j].mp==1 || f[i][j+k].mp==1)\t  \t\t\t{\t  \t\t\t\tf[i][j].num2=k;\t  \t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t\tans=max(ans,f[i][j].num2);\t\t}\t  }\tprintf(\"%d\",ans);\treturn 0;} \n","categories":["学习"],"tags":["题解","洛谷"]},{"title":"最小生成树","url":"/2022/11/15/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","content":"最小生成树有两种算法，Kruskal 和 Prim 算法\n\n最小生成树生成树和最小生成树的定义给定一张无向图，如果在它的子图中，任意两个顶点都是互相连通，并且是一个树结构，那么这棵树叫做生成树。当连接顶点之间的图有权重时，权重之和最小的树结构为最小生成树。\n两种算法与模板最小生成树有两种算法，其中 Kruskal 算法是以边为单位，每次运算操作加边；而 Prim 算法是以点为单位，每次运算操作进行加点。\nKruskal 算法Kruskal 算法是一种贪心算法，其主要思路是在不出现环的情况下尽可能加入最小权值的边。\n模板，以洛谷P3366为例\n#include&lt;bits/stdc++.h&gt;const int MX = 5005;using namespace std;struct Edge{    int u, v, w;}eg[MX*40];int ed[MX];int n, m, ans, tot;int find_end(int node){    return node==ed[node] ? node : ed[node] = find_end(ed[node]);}bool cmp(Edge a, Edge b){    return a.w &lt; b.w;}int main(){    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i=1; i&lt;=n; i++) ed[i] = i;    for (int i=1; i&lt;=m; i++) scanf(\"%d%d%d\", &amp;eg[i].u, &amp;eg[i].v, &amp;eg[i].w);    sort(eg + 1, eg + 1 + m, cmp);    for (int i=1; i&lt;=m; i++)    {        int u = eg[i].u, v = eg[i].v;        int eu = find_end(u), ev = find_end(v);        if (eu != ev)        {            ans += eg[i].w;            if(eu &lt; ev) swap(eu, ev);            ed[ev] = eu;            tot++;        }    }    if (tot == n-1) printf(\"%d\", ans);    else printf(\"orz\");    return 0;}\n\nPrim 算法Prim 算法是也是一种贪心算法，其主要思路是将点分为在建成的最小生成树中和不再最小生成树中两个类型。每次操作为加入距离最小生成树最近的节点。\n模板，以洛谷P3366为例，使用堆优化\n#include&lt;bits/stdc++.h&gt;const int MXN = 5005;using namespace std;struct Edge{    int d, val, next;}eg[(int)4e5+10];typedef pair&lt;int, int&gt; pii;priority_queue &lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; q;int n, m;int head[MXN], top, dis[MXN], tot, ans;bool vis[MXN];void add_edge(int u, int v, int w){    eg[++top].d = v;    eg[top].val = w;    eg[top].next = head[u];    head[u] = top;}void prim(){    memset(dis, 0x3f3f3f3f, sizeof(dis));    dis[1] = 0;    q.push(make_pair(0, 1));    while (!q.empty() &amp;&amp; tot &lt; n)    {        int d = q.top().first, u = q.top().second;        q.pop();        if(vis[u]) continue;        tot++;        ans += d;        vis[u] = 1;        for(int i=head[u]; i; i=eg[i].next)            if (eg[i].val &lt; dis[eg[i].d])                dis[eg[i].d] = eg[i].val, q.push(make_pair(dis[eg[i].d], eg[i].d));    }    }int main(){    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i=1; i&lt;=m; i++)    {        int u, v, w;        scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w);        add_edge(u, v, w);        add_edge(v, u, w);    }    prim();    if (tot == n) printf(\"%d\", ans);    else printf(\"orz\");    return 0;}\n二者优劣Prim在稠密图中比Kruskal优，在稀疏图中比Kruskal劣。\n","categories":["学习"],"tags":["模板","算法"]},{"title":"【置顶】欢迎来到我的博客","url":"/2077/01/01/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/","content":"博士，你还有很多事情需要处理，现在还不能休息哦。\n\n欢迎这里什么都没有，希望您不要在这个毫无意义的博客上浪费时间。\n"}]